{{/* ------------------------------------------------------------
     Load events.md (single file with events array)
------------------------------------------------------------ */}}

{{ $eventsPage := site.GetPage "home/events/events" }}
{{ if not $eventsPage }}
  {{ $found := where site.RegularPages "File.BaseFileName" "events" | first 1 }}
  {{ if gt (len $found) 0 }}{{ $eventsPage = index $found 0 }}{{ end }}
{{ end }}
{{ if not $eventsPage }}{{ warnf "Events page not found" }}{{ return }}{{ end }}

{{ $events := $eventsPage.Params.events }}
{{ if not $events }}{{ warnf "No events array found" }}{{ return }}{{ end }}


<style>
/* ===============================================================
   AUTO SCROLL STYLES (CSS ONLY)
   =============================================================== */

.scroll-box {
    overflow-y: scroll;
    scrollbar-width: none;       /* Firefox */
}
.scroll-box::-webkit-scrollbar {
    display: none;               /* Chrome/Safari */
}

.scroll-box {
  height: 400px;
  overflow: hidden; /* **FIX:** Ensure it's hidden to only show the auto-scroll */
  position: relative;
}

.scroll-inner {
  display: flex;
  flex-direction: column;
  will-change: transform;
  /* scroll-behavior: smooth; // REMOVED: Unnecessary and can interfere with the scroll transform */
}

/* Base animation (JS sets duration) */
@keyframes scroll-up {
  from { transform: translateY(0); }
  /* **FIX:** -50% of the combined (original + clone) height is 100% of the original content height. */
  to   { transform: translateY(-50%); } 
}
</style>


<section class="ftco-section">
  <div class="container-fluid px-4">

    <div class="row justify-content-center mb-5 pb-2">
      <div class="col-md-7 text-center heading-section ftco-animate">
        <span class="subheading">Upcoming</span>
        <h2 class="mb-4">Events</h2>
      </div>
    </div>

    <div class="row">

      {{/* Group by category */}}
      {{ $categories := dict }}

      {{ range $events }}
        {{ $cat := .category | default "Uncategorized" }}

        {{ $item := dict
            "title" (.title)
            "category" (.category)
            "date" (.date)
            "description" (.description)
            "image" (.image)
        }}

        {{ $existing := index $categories $cat | default (slice) }}
        {{ $newList := $existing | append $item }}
        {{ $categories = merge $categories (dict $cat $newList) }}
      {{ end }}

      {{/* Render Columns */}}
      {{ range $cat, $eventsSlice := $categories }}

      <div class="col-md-6 col-lg-4 menu-wrap mb-4 ">
        <div class="heading-menu text-center ftco-animate mb-3 ">
          <h3 class="text-decoration-underline"> {{ $cat }}</h3>
        </div>

        <div class="scroll-box">
          <div class="scroll-inner">

            {{/* Only print ORIGINAL dataset. JS will duplicate it */}}
            {{ range $eventsSlice }}
              {{ partial "events_card.html" . }}
            {{ end }}

          </div>
        </div>
      </div>

      {{ end }}

    </div>
  </div>
</section>

<script>
document.addEventListener("DOMContentLoaded", function () {

  const boxes = document.querySelectorAll(".scroll-box");

  boxes.forEach(box => {

    const inner = box.querySelector(".scroll-inner");
    
    /* ... (Existing cleanup and preparation code remains the same) ... */

    /* Remove whitespace text nodes */
    [...inner.childNodes].forEach(node => {
      if (node.nodeType === 3) node.remove();
    });

    /* Disable FTCO animation classes to avoid height jumps */
    inner.querySelectorAll(".ftco-animate, .fadeInUp, .ftco-animated")
      .forEach(el => el.classList.remove("ftco-animate", "fadeInUp", "ftco-animated"));

      
    // --- 1. Clone and Calculate ---
      
    const originalItems = [...inner.children];
    if (originalItems.length === 0) return; 

    /* Clone items for infinite scroll */
    originalItems.forEach(item => {
      const clone = item.cloneNode(true);
      inner.appendChild(clone);
    });

    /* Calculate scroll duration based on ORIGINAL content height */
    const originalContentHeight = originalItems.reduce((sum, el) => sum + el.offsetHeight, 0);

    const SPEED = 40;   
    const duration = originalContentHeight / SPEED;
    
    // --- 2. Apply Animation ---
    
    inner.style.animation = `scroll-up ${duration}s linear infinite`;
    
    // --- 3. Hover Pause/Resume ---

    /* Pause on hover */
    box.addEventListener("mouseenter", () => {
      inner.style.animationPlayState = "paused";
    });
    box.addEventListener("mouseleave", () => {
      if (!box._scrollTimer) {
         inner.style.animationPlayState = "running";
      }
    });

    // --- 4. Fixed Manual Scroll Handling ---
    
    /* Manual scroll with mouse/trackpad */
    box.addEventListener("wheel", (e) => {
      e.preventDefault();   

      inner.style.animationPlayState = "paused";

      box.scrollTop += e.deltaY;
      
      // **NEW FIX:** Enforce the scroll limit
      if (e.deltaY > 0 && box.scrollTop >= originalContentHeight) {
          // If scrolling down past the original content height, snap back to the start
          // or prevent scrolling further by setting it to the limit.
          box.scrollTop = originalContentHeight - 1; 
      } else if (e.deltaY < 0 && box.scrollTop < 0) {
          // Prevent scrolling up past the very beginning
          box.scrollTop = 0;
      }
      
      // **Alternative Fix (snapping to start on overscroll):**
      /*
      if (box.scrollTop >= originalContentHeight) {
          box.scrollTop = 0; // Snap back to the beginning
      }
      */

      clearTimeout(box._scrollTimer);
      box._scrollTimer = setTimeout(() => {
        if (!box.matches(":hover")) {
           inner.style.animationPlayState = "running";
        }
        box._scrollTimer = null; 
      }, 1200); 

    }, { passive: false }); 

  });

});
</script>